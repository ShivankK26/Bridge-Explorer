"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentType = exports.ColumnType = exports.validateAndBuildGetResultParams = exports.payloadSearchParams = exports.payloadJSON = exports.QueryEngine = void 0;
const assert_1 = __importDefault(require("assert"));
const queryParameter_1 = require("./queryParameter");
/// Choice of execution engine when executing query via API [default = medium]
var QueryEngine;
(function (QueryEngine) {
    QueryEngine["Medium"] = "medium";
    QueryEngine["Large"] = "large";
})(QueryEngine || (exports.QueryEngine = QueryEngine = {}));
/// Utility method used by router to parse request payloads.
function payloadJSON(payload) {
    return JSON.stringify(payloadRecords(payload));
}
exports.payloadJSON = payloadJSON;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function payloadRecords(payload) {
    if (payload !== undefined) {
        if ("query_parameters" in payload) {
            // Destructure to separate parameters and the rest of the payload
            const { query_parameters, ...rest } = payload;
            return {
                ...rest,
                query_parameters: query_parameters
                    ? queryParameter_1.QueryParameter.unravel(query_parameters)
                    : [],
            };
        }
        return payload;
    }
    return {};
}
/**
 * Converts all arguments into a format
 * which can be converted into a URL path for GET requests.
 */
function payloadSearchParams(payload) {
    if (payload !== undefined) {
        const intermPayload = payload;
        if ("query_parameters" in payload) {
            // Destructure to separate parameters and the rest of the payload
            const { query_parameters, ...rest } = intermPayload;
            // Remove all undefined keys from payload.
            const result = Object.keys(rest).reduce((acc, key) => {
                if (rest[key] !== undefined) {
                    acc[key] = rest[key];
                }
                return acc;
            }, {});
            // Modify query parameter to satisfy API formating requirements.
            if (Array.isArray(payload.query_parameters)) {
                for (const qp of payload.query_parameters) {
                    result[`params.${qp.name}`] = qp.value;
                }
            }
            return result;
        }
        return payload;
    }
    return {};
}
exports.payloadSearchParams = payloadSearchParams;
function validateAndBuildGetResultParams({ limit, offset, sample_count, filters, sort_by, columns, query_parameters, }) {
    (0, assert_1.default)(sample_count === undefined ||
        (limit === undefined && offset === undefined && filters === undefined), "sampling cannot be combined with filters or pagination");
    if (columns !== undefined) {
        if (typeof columns === "string") {
            columns = columns.split(",");
        }
        const output = columns.map((column) => {
            // Check if the column contains quotes
            if (column.includes('"')) {
                // Escape quotes and add quotes around the entire string
                return `"${column.replace(/"/g, '\\"')}"`;
            }
            else {
                // Leave the column unchanged
                return column;
            }
        });
        columns = output.join(",");
    }
    if (sort_by !== undefined && Array.isArray(sort_by)) {
        sort_by = sort_by.join(",");
    }
    query_parameters = query_parameters || [];
    return {
        // It used to be the case that limit was required,
        // but now that they have introduced some other filters that
        // are incompatible with this field, it is no longer required.
        // It is becomes required again later, we will need to use withDefaults here.
        limit,
        offset,
        sample_count,
        filters,
        sort_by,
        columns,
        query_parameters,
    };
}
exports.validateAndBuildGetResultParams = validateAndBuildGetResultParams;
var ColumnType;
(function (ColumnType) {
    ColumnType["Varchar"] = "varchar";
    ColumnType["Integer"] = "integer";
    ColumnType["Double"] = "double";
    ColumnType["Boolean"] = "boolean";
    ColumnType["Timestamp"] = "timestamp";
})(ColumnType || (exports.ColumnType = ColumnType = {}));
/**
 * All supported API content types
 */
var ContentType;
(function (ContentType) {
    ContentType["Json"] = "application/json";
    ContentType["Csv"] = "text/csv";
    ContentType["NDJson"] = "application/x-ndjson";
})(ContentType || (exports.ContentType = ContentType = {}));
