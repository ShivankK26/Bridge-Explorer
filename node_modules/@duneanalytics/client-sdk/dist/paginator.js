"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Paginator = void 0;
const types_1 = require("./types");
class Paginator {
    constructor(client, executionId, pageSize, firstPage, totalRows) {
        this.client = client;
        this.executionId = executionId;
        this.pageSize = pageSize;
        this.currentPageNumber = firstPage.number;
        this.pageCache = new Map();
        this.pageCache.set(this.currentPageNumber, firstPage);
        this.totalRows = totalRows;
    }
    static async new(client, executionStatus, pageLimit) {
        if (executionStatus.state !== types_1.ExecutionState.COMPLETED) {
            throw new Error("Paginator can only be constructed on Complete execution state.");
        }
        const executionId = executionStatus.execution_id;
        const results = await client.getExecutionResults(executionId, {
            limit: pageLimit,
            offset: 0,
        });
        if (!results.result) {
            throw new Error("Can't paginate execution without results.");
        }
        const totalRows = results.result.metadata.total_row_count;
        const firstPage = {
            number: 1,
            values: results.result.rows,
        };
        return new Paginator(client, executionId, pageLimit, firstPage, totalRows);
    }
    maxPage() {
        return Math.ceil(this.totalRows / this.pageSize);
    }
    async nextPage() {
        if (this.currentPageNumber < this.maxPage()) {
            const nextPage = await this.getPage(this.currentPageNumber + 1);
            this.currentPageNumber++;
            return nextPage;
        }
        console.warn("You are already on the last page!");
    }
    async previousPage() {
        if (this.currentPageNumber > 1) {
            const previousPage = await this.getPage(this.currentPageNumber - 1);
            this.currentPageNumber--;
            return previousPage;
        }
        console.warn("You are already on the first page.");
    }
    async lastPage() {
        const lastPage = await this.getPage(this.maxPage());
        this.currentPageNumber = this.maxPage();
        return lastPage;
    }
    async getPage(n) {
        if (n >= 1 && n <= this.maxPage()) {
            if (this.pageCache.has(n)) {
                return this.pageCache.get(n);
            }
            const pageNResults = await this.client.getExecutionResults(this.executionId, {
                limit: this.pageSize,
                // Page 1 has offset 0.
                offset: this.pageSize * (n - 1),
            });
            if (!pageNResults.result) {
                throw new Error(`Expected results for page ${n} of ${this.maxPage}`);
            }
            const pageN = {
                number: n,
                values: pageNResults.result.rows,
            };
            this.pageCache.set(n, pageN);
            return pageN;
        }
        console.warn(`Invalid page number requested ${n}: Must be contained in [1, ${this.maxPage()}]`);
    }
    getCurrentPageValues() {
        return this.pageCache.get(this.currentPageNumber);
    }
}
exports.Paginator = Paginator;
