"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Router = void 0;
const types_1 = require("../types");
const package_json_1 = require("../../package.json");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const loglevel_1 = __importDefault(require("loglevel"));
const utils_1 = require("../utils");
const BASE_URL = "https://api.dune.com/api";
var RequestMethod;
(function (RequestMethod) {
    RequestMethod["GET"] = "GET";
    RequestMethod["POST"] = "POST";
    RequestMethod["PATCH"] = "PATCH";
    RequestMethod["DELETE"] = "DELETE";
})(RequestMethod || (RequestMethod = {}));
/**
 * This class implements all the routes defined in the Dune API Docs:
 * https://docs.dune.com/api-reference/overview/introduction
 */
class Router {
    constructor(apiKey, apiVersion = "v1") {
        this.apiKey = apiKey;
        this.apiVersion = apiVersion;
    }
    /**
     * Allows a post to any route supported by DuneAPI.
     * Meant to be low level call only used by available functions,
     * but accessible if new routes become available before the SDK catches up.
     * @param route request path of the http post
     * @param params payload sent with request (should be aligned with what the interface supports)
     * @returns a flexible data type representing whatever is expected to be returned from the request.
     */
    async post(route, params, content_type = types_1.ContentType.Json) {
        return this._request(RequestMethod.POST, this.url(route), params, false, content_type);
    }
    async _handleResponse(responsePromise) {
        let result;
        try {
            const response = await responsePromise;
            if (!response.ok) {
                loglevel_1.default.error(utils_1.logPrefix, `response error ${response.status} - ${response.statusText}`);
            }
            const clonedResponse = response.clone();
            try {
                // Attempt to parse JSON
                result = await response.json();
            }
            catch (_a) {
                // Fallback to text if JSON parsing fails
                // This fallback is used for CSV retrieving methods.
                result = await clonedResponse.text();
            }
            // Check for error in result after parsing
            if (result.error) {
                loglevel_1.default.error(utils_1.logPrefix, `error contained in response ${JSON.stringify(result)}`);
                // Assuming DuneError is a custom Error you'd like to throw
                throw new types_1.DuneError(result.error instanceof Object ? result.error.type : result.error);
            }
        }
        catch (error) {
            loglevel_1.default.error(utils_1.logPrefix, `caught unhandled response error ${JSON.stringify(error)}`);
            throw new types_1.DuneError(`Response ${error}`);
        }
        return result;
    }
    async _request(method, url, payload, raw = false, content_type = types_1.ContentType.Json) {
        let body;
        if (Buffer.isBuffer(payload)) {
            body = payload;
        }
        else {
            body = (0, types_1.payloadJSON)(payload);
        }
        loglevel_1.default.debug(utils_1.logPrefix, `${method} received input url=${url}, payload=${body}`);
        const requestData = {
            method,
            headers: {
                "x-dune-api-key": this.apiKey,
                "User-Agent": `client-sdk@${package_json_1.version} (https://www.npmjs.com/package/@duneanalytics/client-sdk)`,
                "Content-Type": content_type,
            },
            // conditionally add the body property
            ...(method !== RequestMethod.GET && {
                body,
            }),
        };
        let pathParams = "";
        /// Build Url Search Parameters on GET
        if (method === "GET" && payload) {
            const searchParams = new URLSearchParams((0, types_1.payloadSearchParams)(payload)).toString();
            pathParams = `?${searchParams}`;
        }
        loglevel_1.default.debug("Final request URL", url + pathParams);
        const response = (0, cross_fetch_1.default)(url + pathParams, requestData);
        if (raw) {
            return response;
        }
        return this._handleResponse(response);
    }
    async _get(route, params, raw = false) {
        return this._request(RequestMethod.GET, this.url(route), params, raw);
    }
    async _delete(route) {
        return this._request(RequestMethod.DELETE, this.url(route));
    }
    async _getByUrl(url, params, raw = false) {
        return this._request(RequestMethod.GET, url, params, raw);
    }
    async _patch(route, params) {
        return this._request(RequestMethod.PATCH, this.url(route), params);
    }
    url(route) {
        return `${BASE_URL}/${this.apiVersion}/${route}`;
    }
}
exports.Router = Router;
